#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "satox/blockchain/blockchain_manager.hpp"
#include "satox/blockchain/block.hpp"
#include <vector>
#include <string>
#include <chrono>
#include <thread>
#include <atomic>

class BlockchainVulnerabilityTests : public ::testing::Test {
protected:
    void SetUp() override {
        manager = &satox::blockchain::BlockchainManager::getInstance();
    }

    void TearDown() override {}

    satox::blockchain::BlockchainManager* manager;
};

// Double-spending via config
TEST_F(BlockchainVulnerabilityTests, DoubleSpendingProtection) {
    satox::blockchain::BlockchainConfig config;
    config.name = "blockchain_double_spend_test";
    EXPECT_NO_THROW({ manager->validateConfig(config); });
}

// 51% attack via config
TEST_F(BlockchainVulnerabilityTests, FiftyOnePercentAttackProtection) {
    satox::blockchain::BlockchainConfig config;
    config.networkConfig.host = "malicious_host";
    EXPECT_NO_THROW({ manager->validateConfig(config); });
}

// Transaction malleability via config
TEST_F(BlockchainVulnerabilityTests, TransactionMalleabilityProtection) {
    satox::blockchain::BlockchainConfig config;
    config.additionalConfig = { {"tx", "malleable"} };
    EXPECT_NO_THROW({ manager->validateConfig(config); });
}

// Race condition via config
TEST_F(BlockchainVulnerabilityTests, RaceConditionProtection) {
    const int num_threads = 5;
    std::vector<std::thread> threads;
    for (int i = 0; i < num_threads; ++i) {
        threads.emplace_back([this]() {
            satox::blockchain::BlockchainConfig config;
            config.name = "race_test";
            manager->validateConfig(config);
        });
    }
    for (auto& t : threads) t.join();
    SUCCEED();
}

// Buffer overflow via config
TEST_F(BlockchainVulnerabilityTests, BufferOverflowProtection) {
    satox::blockchain::BlockchainConfig config;
    config.name = std::string(1000000, 'A');
    EXPECT_NO_THROW({ manager->validateConfig(config); });
}

// Test for invalid block structure vulnerability
TEST_F(BlockchainVulnerabilityTests, InvalidBlockStructureProtection) {
    // Test with empty block
    auto empty_block = std::make_shared<satox::blockchain::Block>();
    auto result = manager->validateBlock(empty_block);
    // Should handle empty blocks appropriately
    
    // Test with invalid hash
    auto invalid_hash_block = std::make_shared<satox::blockchain::Block>();
    result = manager->validateBlock(invalid_hash_block);
    // Should handle invalid blocks appropriately
}

// Test for memory exhaustion vulnerability
TEST_F(BlockchainVulnerabilityTests, MemoryExhaustionProtection) {
    // Try to create extremely large blocks
    std::string large_data(1000000, 'A'); // 1MB of data
    
    EXPECT_NO_THROW({
        // Should handle large data appropriately
        auto block = std::make_shared<satox::blockchain::Block>();
        auto result = manager->validateBlock(block);
        // Should not crash or exhaust memory
    });
    
    // Try to create many small blocks rapidly
    for (int i = 0; i < 1000; ++i) {
        EXPECT_NO_THROW({
            auto block = std::make_shared<satox::blockchain::Block>();
            auto result = manager->validateBlock(block);
            // Should not crash or exhaust memory
        });
    }
}

// Test for timestamp manipulation vulnerability
TEST_F(BlockchainVulnerabilityTests, TimestampManipulationProtection) {
    // Test with very old timestamp
    auto old_block = std::make_shared<satox::blockchain::Block>();
    auto result = manager->validateBlock(old_block);
    // Should handle old blocks appropriately
    
    // Test with very recent timestamp (potential manipulation)
    auto recent_block = std::make_shared<satox::blockchain::Block>();
    result = manager->validateBlock(recent_block);
    // Should handle recent blocks appropriately
}

// Test for transaction replay vulnerability
TEST_F(BlockchainVulnerabilityTests, TransactionReplayProtection) {
    // Create a transaction
    auto transaction = manager->createTransaction("sender", "receiver", 25.0);
    EXPECT_TRUE(transaction != nullptr);
    
    // Try to replay the same transaction
    auto replayed_transaction = manager->createTransaction("sender", "receiver", 25.0);
    EXPECT_TRUE(replayed_transaction != nullptr);
    
    // Should handle replayed transactions appropriately
    EXPECT_TRUE(transaction != replayed_transaction);
}

// Test for nonce manipulation vulnerability
TEST_F(BlockchainVulnerabilityTests, NonceManipulationProtection) {
    // Create a transaction with specific nonce
    auto transaction = manager->createTransaction("sender", "receiver", 30.0);
    EXPECT_TRUE(transaction != nullptr);
    
    // Try to create another transaction with the same nonce
    auto duplicate_nonce_transaction = manager->createTransaction("sender", "receiver2", 20.0);
    EXPECT_TRUE(duplicate_nonce_transaction != nullptr);
    
    // Should handle duplicate nonces appropriately
    EXPECT_TRUE(transaction != duplicate_nonce_transaction);
}

// Test for block size manipulation vulnerability
TEST_F(BlockchainVulnerabilityTests, BlockSizeManipulationProtection) {
    // Try to create block with maximum allowed size
    std::string max_size_data(1000000, 'A'); // 1MB
    
    EXPECT_NO_THROW({
        auto block = std::make_shared<satox::blockchain::Block>();
        auto result = manager->validateBlock(block);
        // Should handle large blocks appropriately
    });
    
    // Try to create block exceeding maximum size
    std::string oversized_data(10000000, 'A'); // 10MB
    EXPECT_NO_THROW({
        auto block = std::make_shared<satox::blockchain::Block>();
        auto result = manager->validateBlock(block);
        // Should handle oversized blocks appropriately
    });
}

// Test for difficulty manipulation vulnerability
TEST_F(BlockchainVulnerabilityTests, DifficultyManipulationProtection) {
    // Try to create block with manipulated difficulty
    auto manipulated_block = std::make_shared<satox::blockchain::Block>();
    
    auto result = manager->validateBlock(manipulated_block);
    // Should handle manipulated blocks appropriately
}

// Test for orphan block vulnerability
TEST_F(BlockchainVulnerabilityTests, OrphanBlockProtection) {
    // Create a valid block
    auto valid_block = std::make_shared<satox::blockchain::Block>();
    auto result = manager->validateBlock(valid_block);
    // Should handle valid blocks appropriately
    
    // Try to create an orphan block (no parent)
    auto orphan_block = std::make_shared<satox::blockchain::Block>();
    result = manager->validateBlock(orphan_block);
    // Should handle orphan blocks appropriately
}

// Test for consensus manipulation vulnerability
TEST_F(BlockchainVulnerabilityTests, ConsensusManipulationProtection) {
    // Try to force consensus with invalid data
    std::vector<std::string> invalid_consensus_data = {
        "invalid_consensus_1",
        "fake_consensus",
        "manipulated_consensus"
    };
    
    for (const auto& invalid_data : invalid_consensus_data) {
        satox::blockchain::BlockchainConfig config;
        config.name = invalid_data;
        EXPECT_NO_THROW({
            // Should handle invalid consensus data appropriately
            manager->validateConfig(config);
        });
    }
    
    // Try to manipulate consensus with timing attacks
    auto start = std::chrono::high_resolution_clock::now();
    satox::blockchain::BlockchainConfig config;
    config.name = "valid_consensus_data";
    auto consensus_result = manager->validateConfig(config);
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    // Consensus validation should complete within reasonable time
    EXPECT_LT(duration.count(), 1000) << "Consensus validation took too long: " << duration.count() << "ms";
} 