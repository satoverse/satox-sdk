import { BlockProcessor, Block, Transaction } from "../src/core/BlockProcessor";\n\ndescribe("BlockProcessor", () => {\n    let processor: BlockProcessor;\n    let sampleBlock: Block;\n\n    beforeEach(() => {\n        processor = new BlockProcessor();\n        sampleBlock = {\n            hash: "0x123",\n            previousHash: "0x456",\n            timestamp: 1234567890,\n            transactions: [\n                {\n                    hash: "0x789",\n                    sender: "0xabc",\n                    receiver: "0xdef",\n                    amount: 100\n                }\n            ]\n        };\n    });\n\n    describe("initialize", () => {\n        it("should initialize successfully", async () => {\n            const result = await processor.initialize();\n            expect(result).toBe(true);\n            expect(processor.getLastError()).toBe("");\n        });\n    });\n\n    describe("shutdown", () => {\n        it("should shutdown successfully", async () => {\n            await processor.initialize();\n            const result = await processor.shutdown();\n            expect(result).toBe(true);\n            expect(await processor.getCurrentBlock()).toBeNull();\n        });\n    });\n\n    describe("processBlock", () => {\n        beforeEach(async () => {\n            await processor.initialize();\n        });\n\n        it("should process a valid block", async () => {\n            const blockData = Buffer.from(JSON.stringify(sampleBlock));\n            const result = await processor.processBlock(blockData);\n            expect(result).toBe(true);\n            expect(await processor.getCurrentBlock()).toEqual(sampleBlock);\n        });\n\n        it("should reject an invalid block", async () => {\n            const invalidBlock = { hash: "0x123" };\n            const blockData = Buffer.from(JSON.stringify(invalidBlock));\n            const result = await processor.processBlock(blockData);\n            expect(result).toBe(false);\n            expect(processor.getLastError()).toContain("Missing required field");\n        });\n\n        it("should reject a block with invalid transaction", async () => {\n            const block = {\n                ...sampleBlock,\n                transactions: [{ hash: "0x789" }]\n            };\n            const blockData = Buffer.from(JSON.stringify(block));\n            const result = await processor.processBlock(blockData);\n            expect(result).toBe(false);\n            expect(processor.getLastError()).toContain("Missing required field");\n        });\n    });\n\n    describe("getBlock", () => {\n        beforeEach(async () => {\n            await processor.initialize();\n            const blockData = Buffer.from(JSON.stringify(sampleBlock));\n            await processor.processBlock(blockData);\n        });\n\n        it("should get a block by hash", async () => {\n            const block = await processor.getBlock(sampleBlock.hash);\n            expect(block).toEqual(sampleBlock);\n        });\n\n        it("should return null for non-existent block", async () => {\n            const block = await processor.getBlock("non-existent");\n            expect(block).toBeNull();\n        });\n    });\n\n    describe("error handling", () => {\n        it("should handle errors when not initialized", async () => {\n            const result = await processor.processBlock(Buffer.from("{}"));\n            expect(result).toBe(false);\n            expect(processor.getLastError()).toContain("not initialized");\n        });\n\n        it("should clear error message", async () => {\n            await processor.processBlock(Buffer.from("{}"));\n            expect(processor.getLastError()).not.toBe("");\n            processor.clearLastError();\n            expect(processor.getLastError()).toBe("");\n        });\n    });\n});
